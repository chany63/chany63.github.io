var store = [{
        "title": "Simple linux commands",
        "excerpt":"리눅스 명령어                  명령어       의미       비고                       mv       파일 이동                         echo       출력       echo (내용) &gt; 파일: 파일에 덮어씌우기                 cat       파일 미리보기                         ls -a       숨김 파일 표시                         python -m (모듈)       파이썬 라이브러리를 모듈로써 설치할 때                      echo / cat / 연습      mkdir / mv / 상대경로 연습      python 명령어 중 -m mod에 대한 설명임 (예: python3 -m venv .venv 이름이  .venv인 가상환경 모듈 설치)   경로: 상대경로, 절대경로      상대경로   현재 폴더: ./   상위 폴더: ../   상위 폴더의 상위 폴더: ../../   최상위 폴더: /   default: ~  ","categories": ["Linux"],
        "tags": ["Linux"],
        "url": "/linux/linuxcmd/",
        "teaser": null
      },{
        "title": "REST API",
        "excerpt":"REST란?      자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 것   상태전달 형식      데이터가 요청되는 시점에서 정보 전달   JSON 혹은 XML을 통해 데이터를 주고받음   = 즉 REST는 네트워크 상에서 서버와 클라이언트 사이의 통신 방식 중 하나   해당 포스트는 REST API 제대로 알고 사용하기 : NHN Cloud Meetup를 참조하여 만들었습니다.  ","categories": ["Backend study"],
        "tags": ["Backend","DB"],
        "url": "/backend%20study/restapi/",
        "teaser": null
      },{
        "title": "First post: test",
        "excerpt":"this is a test page  ","categories": ["Blog"],
        "tags": ["Blog","GitHub Page","Git"],
        "url": "/blog/testpage/",
        "teaser": null
      },{
        "title": "What is DOM?",
        "excerpt":"DOM이란?   = Document Object Model(문서 객체 모델)      문서 객체란, &lt;html&gt;이나 &lt;body&gt; 같은 html문서의 태그들을 JavaScript가 이용할 수 있는 객체(object)로 만들면 그것을 문서 객체라고 함   즉, DOM은 웹 브라우저가 HTML 페이지를 인식하는 방식을 의미함.      트리 구조로 형성되어 있는 DOM   DOM은 tree형식의 자료구조를 가지고 있다.      JavaScript로 문서객체를 생성한다?      정적 생성: 웹 브라우저가 HTML 페이지에 적혀 있는 태그를 읽으면 생성   동적 생성: HTML 페이지에 없던 문서객체를 JavaScript를 이용해서 생성할 수 있음   DOM 사용 예시   &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; 문서객체 모델(DOM)&lt;/title&gt; &lt;script type= \"text/javascript\"&gt;  &lt;/script&gt; &lt;/head&gt; &lt;body&gt; \t&lt;h1 id=\"header_1\" name=\"\"&gt;HEADER-1 &lt;/h1&gt; \t&lt;div&gt; \t\t&lt;h1 id=\"header_2\"&gt;HEADER-2&lt;/h1&gt; \t&lt;/div&gt; \t&lt;hr&gt; \t&lt;h1 id=\"clock\"&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   여기서 javaScript를 통해 동적으로 문서객체를 생성해보겠다.   var header = document.createElement('h2');   var textNode = document.createTextNode('Hello DOM');   header.appendChild(textNode);   document.body.appendChild(header);   &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; 문서객체 모델(DOM)&lt;/title&gt; &lt;script type= \"text/javascript\"&gt; \twindow.onlad = function(){ \t\t//1. 문서 객체 생성 \t\tvar header = document.createElement('h2'); \t\tvar textNode = document.createTextNode('Hello DOM');  \t\t//2. 노드(요소/텍스트)를 연결 \t\theader.appendChild(textNode);  \t\t//3. body 문서 객체에 header 문서 객체를 추가 \t\tdocument.body.appendChild(header); \t}; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; \t&lt;h1 id=\"header_1\" name=\"\"&gt;HEADER-1 &lt;/h1&gt; \t&lt;div&gt; \t\t&lt;h1 id=\"header_2\"&gt;HEADER-2&lt;/h1&gt; \t&lt;/div&gt; \t&lt;hr&gt; \t&lt;h1 id=\"clock\"&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   참고: https://m.blog.naver.com/magnking/220972680805  ","categories": ["Frontend study"],
        "tags": ["Frontend","HTML","DOM"],
        "url": "/frontend%20study/DOM/",
        "teaser": null
      },{
        "title": "Github Blog",
        "excerpt":"첫 인턴을 준비하던 주중, 포트폴리오와 이력서 제출을 해야하는데 아직 만들어 놓은 것이 없어 여러 양식을 참고하다가 github.io를 이용해 나만의 블로그를 만들기로 하였다.   여러 블로그를 찾아보며 블로그 만드는 데에 참고하였지만, apple silicon을 사용하는 블로거는 찾기 힘들어 직접 만들어 보기로 하였다.   github 블로그를 꾸미는데 가장 사람들이 많이 쓰는 jekyll 이라는 웹사이트 툴을 활용할 계획이다.   Homebrew 설치      homebrew는 오픈소스 라이브러리를 제대로 활용하기에 아주 편리한 소스인데 jekyll을 활용하기 위해서는 거의 필수라고 볼 수 있기 때문에 먼저 설치해줘야 한다.   그렇다면 homebrew를 어떻게 m1 맥북에 설치하냐..?            그냥 homebrew 홈페이지에서 하라는대로 하면 아주 간단하다 ㅋㅋ..                homebrew 홈페이지: https://brew.sh                      install homebrew 밑에 나와있는 저 문구(오른쪽 클립보드 아이콘을 클릭하면 저절로 복사된다)를 복사하여 사용하는 터미널에 복붙하면 완료.           설치 과정은 터미널에서 쭉 진행되며 next step을 위해서는 뭘 하라고 친절하게 설명이 나온다.           그대로 따라하여 설치가 완료되면 다음 문구를 통해 잘 됐는지 확인해준다             $ brew --version                              위와 같은 결과가 출력되면 homebrew 설치에 성공한 것이다!                   Jekyll이란?   Jekyll은 정적 웹사이트 생성기로 Ruby 언어로 제작되었으며, 손쉽게 글을 쓸 수 있는 마크다운 글쓰기를 지원한다.(필자가 이 글을 쓰며 활용하고 있는 notion 또한 마크다운 글쓰기를 지원하는 대표적인 플랫폼이다)   GitHub Pages는 Jekyll로 구동되기 때문에 내가 원하는 사이트를 GitHub을 통해 무려 공짜로 만들 수 있다.   원하는 대로 커스터마이징이 가능하고 다양한 테마를 쓸 수 있다는 엄청난 장점이 있다.   Ruby 설치           rbenv란?       rbenv는 여러 종류의 Ruby를 설치할 수 있게 한다. rbenv 자체는 Ruby 설치를 지원하지 않습니다만, ruby-build라는 유명한 플러그인에서 Ruby를 설치할 수 있다. rbenv, ruby-build 모두 macOS, Linux나 다른 UNIX-계열 운영체제에서 사용가능하다.            ruby-build란?       ruby-build는 다른 버전의 Ruby를 임의의 디렉터리에 컴파일하고 설치할 수 있게 하는 rbenv의 플러그인이다. ruby-build는 rbenv 없이 독자적으로 사용 할 수도 있다. macOS, Linux나 다른 UNIX-계열 운영체제에서만 사용 가능합하다.       macOS에서는 rbenv를 통해 Ruby를 설치한다. rbenv는 여러개의 Ruby 버전을 독립적으로 관리할 수 있도록 하는 패키지이다. 그리고 ruby-build 플러그인도 설치한다.   아까 설치한 homebrew를 활용해 rbenv와 ruby-build를 설치한다   $ brew install rbenv ruby-build      설치 가능한 ruby version을 확인한다   $ rbenv install -l      안정성을 위해 필자는 가장 최신 버전이 아닌 3.0.5 버전을 설치하였다   $ rbenv install 3.0.5      설치가 완료되면 가장 마지막 줄에 위와 같은 문구가 뜬다. 따라해준다.   $ rbenv global 3.0.5 $ rbenv versions #세팅 확인      3.0.5로 설정되어 있는 것을 확인   Bundler 설치      이제 ruby의 gem을 통해 Bundler를 설치하려고 하면, 에러가 뜬다..   $ gem install bundler ERROR:  While executing gem ... (Gem::FilePermissionError)     You don't have write permissions for the /Library/Ruby/Gems/2.6.0 directory.   위 rbenv의 환경변수 설정이 아직 안돼서이다   rbenv 환경변수 설정   $ echo $SHELL      기본 쉘이 zsh임을 확인   $ open ~/.zshrc   쭈욱 내려가서 아래 두줄을 그대로 넣어주면 된다.   export PATH={$Home}/.rbenv/bin:$PATH &amp;&amp; \\ eval \"$(rbenv init -)\"   저장 후 종료   $ source ~/.zshrc   $ gem install bundler   Jekyll 설치, 블로그 생성      이후 xcode의 command line tools가 정상적으로 설치가 되어있다면 gem을 통해 jekyll을 설치할 수 있다   $ gem install jekyll   Visual Studio Code에 jekyll 개발환경 연동      미리 만들어 놓은 본인의 github page repo를 항상 하던대로 vsc에 연동하면 된다!      위쪽 그림과 같이 빠른 메뉴를 이용하거나, 아래쪽 그림과 같이 cmd + shift + p를 눌러 메뉴에서 git: clone을 치면         위와 같은 창이 뜬다.      위 박스 안에 있는 걸 그대로 복붙해주면 원하는 로컬 디렉토리에 저 repo를 연동할 수 있다!   로컬 디렉토리에 생성된 username.github.io로 cd(change directory)한 후   해당 디렉토리에 jekyll을 생성해준다      $ jekyll new ./ $ bundle install   사이트가 생성됐으니 실행해보자!   $ bundle exec jekyll serve   자, 이제 평소에 로컬과 github를 연동하듯이 똑같이 하면 된다   # git 생성(이미 git clone을 통해 initialize 해주었기 때문에 해줄 필요없다) $ git init  # git 상태 확인 $ git status  # 모든 change를 stage한다 $ git add .  # 잘 staged 됐는지 git 상태 확인 $ git status  # 커밋 $ git commit -m 'Initial commit'  # 커밋 내역 확인 $ git log  # git 원격저장소로 log remote(vsc와 연동돼있다면 이미 돼있을것) $ git remote add origin https://github.com/username/username.github.io.git  # remote 잘 됐는지 확인 $ git remote -v  # 로컬과 github 동기화 $ git push -u origin master   자 이제 잠시 후 username.github.io에 접속하면? jekyll 테마가 입혀진 초기 상태의 본인 블로그를 확인할 수 있다! Congrats!!     ","categories": ["Blog"],
        "tags": ["Blog","GitHub Page","Git"],
        "url": "/blog/githubblog/",
        "teaser": null
      },{
        "title": "About JSON",
        "excerpt":"JSON (JavaScript Object Notation)      JavaScript Object Notation라는 의미의 축약어로 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 DATA 교환 형식   Javascript에서 객체를 만들 때 사용하는 표현식을 의미한다. (javascript 탭)   JSON 표현식은 사람과 기계 모두 이해하기 쉬우며 용량이 작아서, 최근에는 JSON이 XML을 대체해서 데이터 전송 등에 많이 사용한다.   JSON은 데이터 포맷일 뿐이며 어떠한 통신 방법도, 프로그래밍 문법도 아닌 단순히 데이터를 표시하는 표현 방법일 뿐이다.   JSON의 특징      서버와 클라이언트 간의 교류에서 일반적으로 많이 사용된다.   자바스크립트 객체 표기법과 아주 유사하다.   자바스크립트를 이용하여 JSON 형식의 문서를 쉽게 자바스크립트 객체로 변환할 수 있는 이점이 있다.   JSON 문서 형식은 자바스크립트 객체의 형식을 기반으로 만들어졌다.   자바스크립트의 문법과 굉장히 유사하지만 텍스트 형식일 뿐이다.   다른 프로그래밍 언어를 이용해서도 쉽게 만들 수 있다.   특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON 포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공한다.   JSON의 아래 두 특징과 관련하여..      간단한 웹 어플을 개발하는 과정에서 데이터를 동시에 여러개를 쉽게 전달하고 받아서 처리하기 위해 이 JSON형식을 이용하는 fastapi라는 최신 파이썬 프레임워크를 사용했는데, 파이썬 프레임워크다 보니 JSON형식을 만들기 위해 딕셔너리라는 자료구조를 사용했음.   모든 수집하는 데이터를 JSON 형식과 맞춰주다 보니 파이썬에서 딕셔너리를 만드는 과정을 정말 많이 거치게 됐는데, 공부하던 중 파이썬에 내장되어 있는 zip이라는 꽤나 재미있고 유용한 함수를 발견함   zip()함수 더 알아보기  ","categories": ["Backend study"],
        "tags": ["Backend","Javascript"],
        "url": "/backend%20study/json/",
        "teaser": null
      },{
        "title": "Python Version Control",
        "excerpt":"! 파이썬 프로젝트를 만들시에 파이썬 버전에 따라서 쓸 수 있는 명령어 코드가 다름   시작하기에 앞서, 파이썬 버전 관리가 왜 중요할까?      설명하기 어렵지만, 본인의 상황을 예로 들자면, 파이썬이라는 언어는 계속해서 사용자가 직관적으로 이용하기에 점점 편한 방향으로 업데이트됨, 즉 조금 실수하더라도 저절로 고쳐주고, 형식에 맞지 않아도 저절로 인식함 근데 웹에서 설명하는 코드 그대로 다른 버전에서 돌리면 자동적으로 error나 warning을 해결해주는걸 못하게 됨. 반드시 명시된 파이썬 버전이나 라이브러리 요구사항에 맞춰 설치 후 개발을 진행해야함   만약 개발 중에 오류가 생기면 다시금 필요에 맞게 버전을 변경해야 하는 경우가 생기는데 필자는 이 경우를 기준으로 매뉴얼을 작성하였음. 연습이 필요하지 않다면 5번부터 보면 됨   파이썬 가상환경 만들기 - macOS   가상환경을 만들고 관리하는 모듈을 venv라고 한다.      venv는 보통 사람들이 사용할 수 있는 최신 버전의 python을 설치한다.   하지만 시스템에 여러버전의 파이썬이 있는 경우, python3 또는 원하는 버전을 실행하여 특정 파이썬을 선택할 수 있다.   가상환경을 만들려면 가상환경을 만들 디렉터리를 지정하고 venv 모듈을 스크립트로 실행하는데 디렉터리 경로를 명령행 인자로 전달해야 한다. (참고: root/개발공부/linux)\\   1. 가상환경 디렉터리 생성 및 생성한 디렉으로 이동   $mkdir project $cd project   2. 지정한 디렉에 가상환경 작성   $python3 -m venv .venv      .venv 파일은 숨김파일로 돼 있어 보이지 않음 → ls -a(.으로 시작하는 파일명을 포함한 숨김파일 표시)   3. 가상환경 활성화   $. .venv/bin/activate  or  $source .venv/bin/activate   (.venv)$which python3   /----프로젝트 디렉터리 경로 ----/.venv/bin/python   (.venv)$python -V   여기서 문제 발생: 특정 파이썬 버전을 사용해야 할 경우에는 python3 -m venv .venv를 사용하면 버전을 수정하기 곤란한 상황임   어쩔 수 없이 버전관리를 도와주는 pyenv 패키지를 설치해야겠다.   4. 가상환경 비활성화   (.venv)$deactivate   5. 버전 관리를 위한 pyenv 패키지 설치   $brew install pyenv   $pyenv install 3.10.4 $pyenv global 3.10.4 $pyenv version #3.10.4 (set by /Users/chanymac/.pyenv/version)   6. 쉘 경로 추가   $echo -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n  eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrc $source ~/.zshrc $code ~/.zshrc   $which python3 #/Users/chanymac/.pyenv/shims/python3 $python --version #Python 3.10.4    7. 라이브러리 백업     가상환경 내에 설치했던 라이브러리 백업   $pip freeze &gt; requirements.txt      백업 내용 추출   $pip install -r requirements.txt   8. 가상환경의 파이썬 삭제 후 변경   $rm -r .venv   $python -V   $python3 -m venv .venv      3.의 가상환경 활성화로 돌아가 버전을 확인해보면 특정 파이썬 버전으로 지정됨을 확인 가능   7.의 백업 내용 추출로 라이브러리를 다시 설치해주면 파이썬 버전만 변경된 채로 다시 복구시킬 수 있음   하면서 궁금해졌던 점      쉘 스크립트? 대체 저 문구는 뭘 의미할까(형진이형 노션 참고: https://hjin8.notion.site/J165-Day-02-Linux-bae0f3e947d6429d9f2ea9c5d7926c4f)   zshrc는 뭘까 좀 더 쉽게 파이썬 버전만을 바꾸는 방법은 없는걸까?  ","categories": ["Backend study"],
        "tags": ["Backend","Python"],
        "url": "/backend%20study/pythonversion/",
        "teaser": null
      },{
        "title": "About React",
        "excerpt":"참고 사이트: 웹사이트에 React추가하는 예제 보고 react 연습하기   &lt;div id=\"like_button_container\"&gt;&lt;/div&gt;  &lt;script src=\"https://unpkg.com/react@18/umd/react.development.js\" crossorigin&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\" crossorigin&gt;&lt;/script&gt;  &lt;script src=\"like_button.js\"&gt;&lt;/script&gt;   여기서 처음 두 태그는 react를 실행시키고 3 번째 코드는 만든 컴포넌트를 실행시킨다   const domContainer = document.querySelector('#like_button_container'); const root = ReactDDOM.createRoot(domContainer); root.render(e(LikeButton));   이로써 우리의 페이지에 react 컴포넌트 하나를 추가하는데 성공하였다! wow! 짱쉬워~!   JSX란?   const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;   JSX는 JavaScript를 확장한 문법으로써, React와 함께 사용하게 권장 되는 것이다.   React에서는 본질적으로 렌더링 로직이 UI 로직과 연결된다는 사실을 기반으로 작동하는데, React는 기술을 인위적으로 분리하지 않고 컴포넌트라고 불리는 느슨한 유닛으로 관심사를 분리한다.   const name = 'Josh Perez'; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;   function formatName(user) { \treturn user.firstName + ' ' + user.lastName; }  const user = { \tfirstName: 'Harper', \tlastName: 'Perez' };  const element = ) \t&lt;h1&gt; \t\tHello, {formatName(user)}! \t&lt;/h1&gt; );   JSX 속성 정의   const element = &lt;a href=\"https://www.reactjs.org\"&gt; link &lt;/a&gt;;   const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;   JSX는 객체를 표현   Babel은 JSX를 React.createElement() 호출로 컴파일함   const element = ( \t&lt;h1 className=\"greeting\"&gt; \t\tHello, world! \t&lt;/h1&gt; );   const element = React.createElement( \t'h1', \t{className: 'greeting'}, \t'Hello, world!' );   위 두 코드는 동일함.   React.createElement()는 기본적으로 다음과 같은 객체를 생성함   const element = { \ttype: 'h1', \tprops: { \t\tclassName: 'greeting', \t\tchildren: 'Hello, world!' \t} };   Element Rendering   Element란?      Element는 React앱의 가장 작은 단위임   화면에 표시할 내용을 기술   const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;      브라우저 DOM element와 달리 React element는 일반 객체이며, 쉽게 생성할 수 있   React DOM은 React element와 일치하도록 DOM을 업데이트함   📌 컴포넌트와 Element 개념이 헷갈릴 수 있음 (Element는 컴포넌트의 구성 요소임!)   DOM에 element rendering하기   &lt;div id=\"root\"&gt;&lt;/div&gt;   이 안의 모든 element를 react DOM에서 관리하기 떄문에 root DOM 노드라고 부른다      React로 구현된 애플리케이션은 일반적으로 하나의 root DOM node가 있다   React를 기존 앱에 통합하려는 경우 원하는 만큼 많은 수의 독립된 root DOM node가 있을 수 있음   to render a React element, first pass the DOM element to ReactDOM.createRoot(), then pass the React element to root.render():   const root = ReactDOM.createRoot( \tdocument.getElementById('root') ); const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; root.render(element);   rendering된 element update   지금까지 UI를 update하는 유일한 방법은 새로운 element를 생성하고 root.render()로 전달하는 것.      React element는 불변객체이기 때문에 영화에서 하나의 프레임 같이 특정 시점의 UI를 보여줌   const root = ReactDOM.createRoot( \tdocument.getElementById('root') );  function tick() { \tconst element = ( \t\t&lt;div&gt; \t\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt; \t\t\t&lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; \t\t&lt;/div&gt; \t); \troot.render(element); } //외부 함수를 통해 frame을 변경해주는 것처럼 시점을 바꿔주어 출력을 바꿔줌 setInterval(tick, 1000);   Components와 Props      컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 사용할 수 있음   개념적으로 컴포넌트는 JavaScript 함수와 유사함   function Welcome(props) { \treturn &lt;h1&gt;Hello, {props.neame}&lt;/h1&gt;; }   Component Rendering   const element = &lt;Welcome name=\"Sara\" /&gt;;   그렇다면 페이지에 컴포넌트를 렌더링해보자   function Welcome(props) { \treturn &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }  const root = ReactDOM.createRoot(document.getElementById('root')); const element = &lt;Welcome name=\"Sara\" /&gt;; root render(element);   function Welcome(props) { \treturn &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }  function App() { \treturn ( \t\t&lt;div&gt; \t\t&lt;Welcome name=\"Sara\" /&gt; \t\t&lt;Welcome name=\"Cahal\" /&gt; \t\t&lt;Welcome name=\"Edite\" /&gt; \t\t&lt;/div&gt; \t); }  const root = ReactDOM.createRoot(document.getElementById('root')); root render(&lt;App /&gt;;   function Comment(props) { \treturn ( \t\t&lt;div className=\"Comment\"&gt; \t\t\t&lt;div className=\"UserInfo\"&gt; \t\t\t\t&lt;img className=\"Avatar\" \t\t\t\t\tsrc={props.author.avatarUrl} \t\t\t\t\talt={props.author.name} \t\t\t\t/&gt; \t\t\t\t&lt;div className=\"UserInfo-name\"&gt; \t\t\t\t\t{props.author.name} \t\t\t\t&lt;/div&gt; \t\t\t&lt;/div&gt; \t\t\t&lt;div className=\"Comment-text\"&gt; \t\t\t\t{props.text} \t\t\t&lt;/div&gt; \t\t\t&lt;div className=\"Comment-date\"&gt; \t\t\t\t{formatDate(props.date)} \t\t\t&lt;/div&gt; \t\t&lt;/div&gt; \t); }   위 컴포넌트는 update가 어려우므로 추출해보자   function Avatar(props) { \treturn ( \t\t&lt;img className=\"Avatar\" \t\t\tsrc={props.user.avatarUrl} \t\t\talt={props.user.name} \t\t/&gt; \t); }   function Comment(props) { \treturn ( \t\t&lt;div className=\"Comment\"&gt; \t\t\t&lt;div className=\"UserInfo\"&gt; \t\t\t\t&lt;Avatar user={props.author} /&gt; \t\t\t\t&lt;div className=\"User...   function UserInfo(props) { return ( \t&lt;div className\"userInfo\"&gt; \t\t&lt;Avatar user={props.user} /&gt; \t\t&lt;div className=\"UserInfo-name\"&gt; \t\t\t{props.user.name} \t\t&lt;/div&gt; \t&lt;/div&gt; \t); }   State가 필요한 이유   const root = ReactDOM.createRoot(document.getElementById('root'));  function Clock(props) { \treturn ( \t\t&lt;div&gt; \t\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt; \t\t\t&lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt; \t\t&lt;/div&gt; \t); }  function tick() { \troot.render(&lt;Clock date={new Date()} /&gt;); }  setInterval(tick, 1000);   state를 추가하기 전, 함수에서 클래스로 변환   class Clock extends React.Component { \tconstructor(props) { \t super(props); \t this.state = {date: new Date()}; \t} \trender() { \t\treturn ( \t\t\t&lt;div&gt; \t\t\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt; \t\t\t\t&lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; \t\t\t&lt;/div&gt; \t\t); \t} }      constructor 생성자는 this 에 바인딩 되어 있는 state를 미리 정의하기 위해 써줘야함   super 는 constructor 내에서 this.state를 사용하기 위해 써줘야함   📌자세한 건 다시 공부해야 할듯..   결과적으로,,,   class Clock extends React.Component { \tconstructor(props) { \t super(props); \t this.state = {date: new Date()}; \t} \trender() { \t\treturn ( \t\t\t&lt;div&gt; \t\t\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt; \t\t\t\t&lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt; \t\t\t&lt;/div&gt; \t\t); \t} }  const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;Clock /&gt;);   이제 Clock이 현재 시각을 한 컴포넌트로써 나타내줄 수 있게 해주었다. 이제 해줘야 할건 setInterval의 역할을 담당하는 생명주기 추가  ","categories": ["Frontend study"],
        "tags": ["Frontend","HTML","React"],
        "url": "/frontend%20study/react/",
        "teaser": null
      },{
        "title": "SQLAlchemy",
        "excerpt":"SQLAlchemy   들어가기에 앞서, 본인은 postgresql을 사용할 것이기 때문에 postgresql를 먼저 설치해줘야 한다   brew install postgresql   Python에서 postgresql을 사용하기 위해서는 psycopg2 라이브러리를 사용해야 한다.   psycopg2의 경우 유니코드와 python3를 모두 지원하므로 가장 널리 쓰이는 라이브러리 중 하나.   JDBC와 같은 Database 커넥터이기 때문에 다음과 같은 기능을 지원한다.      Database 연결과 해제   SQL 실행과 트랜잭션 발생   결과 반환   postgresql을 Python 환경에서 사용하는 준비는 모두 끝났다!   1. SQLalchemy설치   pip install sqlalchemy   2. 드라이버(Engine) 및 세션(session) 로드   import sqlalchemy as db  engine = db.create_engine('postgresql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;:5432/&lt;dbname&gt;')  ","categories": ["Backend study"],
        "tags": ["Backend","DB","SQL","Python"],
        "url": "/backend%20study/sqlalchemy/",
        "teaser": null
      },{
        "title": "오랜만의 About Me Update - TIL 1일차",
        "excerpt":"인생 처음으로 취업을 준비하게 되었다.   처음 인턴을 준비할 때 포트폴리오 제출을 위해 이 블로그를 만들었는데 물론 인턴인 줄 알고 들어간 기업에서 갑작스럽게 메인 개발자가 되어 고생이란 고생은 다 겪었지만..   이제는 진짜 취업을 위해 포트폴리오를 업데이트 해야할 때가 왔다.   2023년 1월 이후로 처음 블로그를 업데이트했는데, 정리해보니 생각보다 많은 것들을 했다는 생각에 뿌듯하다. 그리고 그걸 다 기억해서 써낸 내가 뿌듯하다ㅋㅋㅋ   어쨋든 다시금 블로그를 쓰게 되었는데, 이번에는 좀 제대로 해보지 않을까 생각이 든다…   Blog 업데이트           사실 내일배움캠프를 참여하게 되었는데, 사전캠프에서 블로그를 작성하는 일이 있길래 전에 만들었던 블로그를 다시 열어보았다.       모두가 velog와 tistory를 쓰며 글쓰기 버튼을 클릭할 때 github page를 쓰며 일일이 마크다운 문법을 활용하는 것은 것은 정말 사서 고생이라고 생각하긴 하지만,       한 번이라도 git push를 더하겠다는 심정으로 선정하였다. 깃허브 overview에 잔디가 빈 틈 없이 자라 있는 모습이 왠지 모르게 자랑스럽기 때문이다.              퇴사한 이후로 가뭄이 온 건 비밀이다.       물론 다른 블로그들에 비해서 훠어어어얼씬(과장 아님) 이쁘게 만들 수 있는 것이 아주 큰 장점이기도 하다.            About Me 페이지 업데이트       취준에서 가장 우선적으로 해야하는 것은 나를 아는 것, 나를 객관화하는 것이라고 생각한다. 그동안 했던 프로젝트, 근무했던 회사, 수상내역 등을 정리했다.       _config.yml 파일을 열어서 새로이 email 주소를 업데이트했다.       크기에 알맞게 손수 조정한 포트폴리오 속 필요한 이미지, 파일 등등을 root 폴더에 넣고 _pages 폴더에 About Me 페이지 내용을 업데이트했다.                       업데이트를 하는데에 불편함이 발생했다.           처음 이 블로그를 쓸 때는 개발 실무 경험이 매우 없었기 때문에 몰라서 매번 배포 후 테스트했을지 모르겠지만, 프론트엔드 개발할 때에는 로컬 환경 테스팅이 너무나도 중요하다.           코드를 로컬에서 수정할 때마다 화면이 어떻게 바뀌는지 실시간으로 확인을 못한다고 생각하면 세상에는 프론트엔드 개발자가 없을 것이다. 있다 하더라도 다 대머리 빡빡이가 됐을 것이다.           그래서 이번에는 로컬에서 jekyll을 활용하여 블로그를 수정하고 실시간으로 확인할 수 있도록 환경을 구축하였다.                                   jekyll 설치(ruby와 본인이 쓰는 터미널이 설치되어 있다는 가정 하에)               $ gem install jekyll                           성공 화면은 넘어가겠다…                                    jekyll 서버 실행               $ bundle exec jekyll serve                           여기서 bundle exec는 지정된 gem 환경에서 Jekyll을 실행하겠다는 의미이다.               jekyll serve까지 입력하면 로컬에서 서버를 시작해준다.                                                   브라우저에서 확인               브라우저에서 localhost:4000으로 접속하면 로컬에서 수정한 내용을 실시간으로 확인할 수 있다.                              터미널에서도 수정 내용이 반영되는 것을 확인할 수 있다.                                                      TODO           블로그 내용 싹 보기(지식이 없던 옛날 내가 쓴 글들이 어떤 내용이었는지 궁금하다..아니 불안하다..)            수강신청 및 본격적 학습 스타또~      ","categories": ["TIL"],
        "tags": ["Blog","GitHub Page","TIL"],
        "url": "/til/1/",
        "teaser": null
      },{
        "title": "본격적인 Java 공부를 위한 준비 - TIL 2일차",
        "excerpt":"어제부터 거진 밤을 새어가며 취준을 하는데에 있어서 나에게 필요한게 무엇인지, 어떤 방향으로 나아가야 하는지에 대해 고민을 많이 했다.   결론은 어쩌면 내일배움캠프를 참여하지 않게 될 것 같다는 것이다.   너무 좋은 프로그램인 것 같지만 전공자인 나에게 효율적인 시간 분배가 어려울 수도 있겠다, 또 분명 나에게 적합한 더 좋은 선택지가 있겠다는 생각이 들었다.   어쨋든 사전캠프 하루 참여한 시간이 취업에 대해 무지한 나를 이렇게까지 생각하게 만들었다는게 참 고맙다는 생각이 들었다.   그래서 가능하다면 사전캠프는 끝까지 참여하고 싶은 마음이다.   생각하는 시간이 많아서 오늘 학습은 일단 정말 딱 Java 환경설정만 하였다. 나는 Java 개발환경조차 설정이 안되어 있었다, 맙소사.   Java 환경설정(Apple Silicon 기준)           JDK 설치                       OpenJDK 설치           $ brew install openjdk@11                   설치 후 환경변수 설정           $ echo 'export JAVA_HOME=$(/usr/libexec/java_home)' &gt;&gt; ~/.zshrc $ echo 'export PATH=$JAVA_HOME/bin:$PATH' &gt;&gt; ~/.zshrc                              환경변수 설정 후 적용           $ source ~/.zshrc                   설치 확인           $ java --version                                           IDE 설치       나는 기존에 쓰던 VSCode를 사용하였기 때문에 따로 IDE를 설치하지 않았다.       권장되는 IDE인 IntelliJ를 써본 적이 있었는데, 뭐랄까 아직은 좀 불편한 느낌이었다. 상용화가 덜 된 느낌?       얼추 앞으로 이루어야할 목표들을 정리한 내용   나를 걱정해주고 응원해주는 본가의 가족들에게 계획을 이대로 고지했다.           인프런이라는 온라인 강의 사이트가 있는데 거기서 자바 언어에 대한 강의 듣고 혼자 공부 및 실습            백준, 프로그래머스 문제로 코딩 테스트 공부 - 백준 플래티넘, 다이아 목표       여기까지는 코딩 테스트를 위한 공부임       대기업에서는 개발자를 채용할 때 코딩테스트 봄(잘 모르시는 엄빠를 위한 설명이었다)            5월 쯤에 있을 네이버 주최 부스트캠프 지원(여기서도 코딩테스트를 봄) - 이걸 지원하는 이유는 깊이 있는 개발지식을 쌓을 수 있는 것도 있고 포트폴리오랑 취업 연계에 직결돼 있어서임            만약에 합격하면 하반기까지 쭈욱 할 거고(이걸 끝까지 하면 어딜 가든 받아줄 정도)            불합격하면 바로 하반기 공채 쭈욱 쓸거임(이렇게 되면 바로 취업은 될 수 있지만 원하는 곳에 못 가게 될 수도)      ","categories": ["TIL"],
        "tags": ["Java","TIL"],
        "url": "/til/2/",
        "teaser": null
      }]
